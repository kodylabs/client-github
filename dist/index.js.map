{"version":3,"sources":["../src/client.ts","../src/environment.ts","../src/index.ts"],"sourcesContent":["import { Octokit } from \"@octokit/rest\";\nimport { glob } from \"glob\";\nimport simpleGit, { type SimpleGit } from \"simple-git\";\nimport path from \"path\";\nimport fs from \"fs/promises\";\nimport { existsSync } from \"fs\";\nimport { createHash } from \"crypto\";\nimport {\n    elizaLogger,\n    type AgentRuntime,\n    type Client,\n    type IAgentRuntime,\n    knowledge,\n    stringToUuid,\n    type Plugin,\n} from \"@elizaos/core\";\nimport { validateGithubConfig } from \"./environment\";\n\nexport interface GitHubConfig {\n    owner: string;\n    repo: string;\n    branch?: string;\n    path?: string;\n    token: string;\n}\n\nexport class GitHubClient {\n    private octokit: Octokit;\n    private git: SimpleGit;\n    private config: GitHubConfig;\n    private runtime: AgentRuntime;\n    private repoPath: string;\n\n    constructor(runtime: AgentRuntime) {\n        this.runtime = runtime;\n        this.config = {\n            owner: runtime.getSetting(\"GITHUB_OWNER\") as string,\n            repo: runtime.getSetting(\"GITHUB_REPO\") as string,\n            branch: runtime.getSetting(\"GITHUB_BRANCH\") as string,\n            path: runtime.getSetting(\"GITHUB_PATH\") as string,\n            token: runtime.getSetting(\"GITHUB_API_TOKEN\") as string,\n        };\n        this.octokit = new Octokit({ auth: this.config.token });\n        this.git = simpleGit();\n        this.repoPath = path.join(\n            process.cwd(),\n            \".repos\",\n            this.config.owner,\n            this.config.repo\n        );\n    }\n\n    async initialize() {\n        // Create repos directory if it doesn't exist\n        await fs.mkdir(path.join(process.cwd(), \".repos\", this.config.owner), {\n            recursive: true,\n        });\n\n        // Clone or pull repository\n        if (!existsSync(this.repoPath)) {\n            await this.cloneRepository();\n        } else {\n            const git = simpleGit(this.repoPath);\n            await git.pull();\n        }\n\n        // Checkout specified branch if provided\n        if (this.config.branch) {\n            const git = simpleGit(this.repoPath);\n            await git.checkout(this.config.branch);\n        }\n    }\n\n    private async cloneRepository() {\n        const repositoryUrl = `https://${this.config.token}@github.com/${this.config.owner}/${this.config.repo}.git`;\n        const maxRetries = 3;\n        let retries = 0;\n\n        while (retries < maxRetries) {\n            try {\n                await this.git.clone(repositoryUrl, this.repoPath);\n                elizaLogger.log(\n                    `Successfully cloned repository from ${repositoryUrl}`\n                );\n                return;\n            } catch {\n                elizaLogger.error(\n                    `Failed to clone repository from ${repositoryUrl}. Retrying...`\n                );\n                retries++;\n                if (retries === maxRetries) {\n                    throw new Error(\n                        `Unable to clone repository from ${repositoryUrl} after ${maxRetries} retries.`\n                    );\n                }\n            }\n        }\n    }\n\n    async createMemoriesFromFiles() {\n        console.log(\"Create memories\");\n        const searchPath = this.config.path\n            ? path.join(this.repoPath, this.config.path, \"**/*\")\n            : path.join(this.repoPath, \"**/*\");\n\n        const files = await glob(searchPath, { nodir: true });\n\n        for (const file of files) {\n            const relativePath = path.relative(this.repoPath, file);\n            const content = await fs.readFile(file, \"utf-8\");\n            const contentHash = createHash(\"sha256\")\n                .update(content)\n                .digest(\"hex\");\n            const knowledgeId = stringToUuid(\n                `github-${this.config.owner}-${this.config.repo}-${relativePath}`\n            );\n\n            const existingDocument =\n                await this.runtime.documentsManager.getMemoryById(knowledgeId);\n\n            if (\n                existingDocument &&\n                existingDocument.content[\"hash\"] == contentHash\n            ) {\n                continue;\n            }\n\n            console.log(\n                \"Processing knowledge for \",\n                this.runtime.character.name,\n                \" - \",\n                relativePath\n            );\n\n            await knowledge.set(this.runtime, {\n                id: knowledgeId,\n                content: {\n                    text: content,\n                    hash: contentHash,\n                    source: \"github\",\n                    attachments: [],\n                    metadata: {\n                        path: relativePath,\n                        repo: this.config.repo,\n                        owner: this.config.owner,\n                    },\n                },\n            });\n        }\n    }\n\n    async createPullRequest(\n        title: string,\n        branch: string,\n        files: Array<{ path: string; content: string }>,\n        description?: string\n    ) {\n        // Create new branch\n        const git = simpleGit(this.repoPath);\n        await git.checkout([\"-b\", branch]);\n\n        // Write files\n        for (const file of files) {\n            const filePath = path.join(this.repoPath, file.path);\n            await fs.mkdir(path.dirname(filePath), { recursive: true });\n            await fs.writeFile(filePath, file.content);\n        }\n\n        // Commit and push changes\n        await git.add(\".\");\n        await git.commit(title);\n        await git.push(\"origin\", branch);\n\n        // Create PR\n        const pr = await this.octokit.pulls.create({\n            owner: this.config.owner,\n            repo: this.config.repo,\n            title,\n            body: description || title,\n            head: branch,\n            base: this.config.branch || \"main\",\n        });\n\n        return pr.data;\n    }\n\n    async createCommit(\n        message: string,\n        files: Array<{ path: string; content: string }>\n    ) {\n        const git = simpleGit(this.repoPath);\n\n        // Write files\n        for (const file of files) {\n            const filePath = path.join(this.repoPath, file.path);\n            await fs.mkdir(path.dirname(filePath), { recursive: true });\n            await fs.writeFile(filePath, file.content);\n        }\n\n        // Commit and push changes\n        await git.add(\".\");\n        await git.commit(message);\n        await git.push();\n    }\n\n    async stop() {\n        elizaLogger.warn(\"GitHub client does not support stopping yet\");\n    }\n}\n\nexport const GitHubClientInterface: Client = {\n    name: 'github',\n    start: async (runtime: IAgentRuntime) => {\n        await validateGithubConfig(runtime);\n        elizaLogger.log(\"GitHubClientInterface start\");\n\n        const client = new GitHubClient(runtime as AgentRuntime);\n        await client.initialize();\n        await client.createMemoriesFromFiles();\n\n        return client;\n    },\n};","import type { IAgentRuntime } from \"@elizaos/core\";\nimport { z } from \"zod\";\n\nexport const githubEnvSchema = z.object({\n    GITHUB_OWNER: z.string().min(1, \"GitHub owner is required\"),\n    GITHUB_REPO: z.string().min(1, \"GitHub repo is required\"),\n    GITHUB_BRANCH: z.string().min(1, \"GitHub branch is required\"),\n    GITHUB_PATH: z.string().min(1, \"GitHub path is required\"),\n    GITHUB_API_TOKEN: z.string().min(1, \"GitHub API token is required\"),\n});\n\nexport type GithubConfig = z.infer<typeof githubEnvSchema>;\n\nexport async function validateGithubConfig(\n    runtime: IAgentRuntime\n): Promise<GithubConfig> {\n    try {\n        const config = {\n            GITHUB_OWNER: runtime.getSetting(\"GITHUB_OWNER\"),\n            GITHUB_REPO: runtime.getSetting(\"GITHUB_REPO\"),\n            GITHUB_BRANCH: runtime.getSetting(\"GITHUB_BRANCH\"),\n            GITHUB_PATH: runtime.getSetting(\"GITHUB_PATH\"),\n            GITHUB_API_TOKEN: runtime.getSetting(\"GITHUB_API_TOKEN\"),\n        };\n\n        return githubEnvSchema.parse(config);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `GitHub configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import { GitHubClientInterface } from \"./client\";\n\nconst githubPlugin = {\n    name: \"github\",\n    description: \"GitHub client\",\n    clients: [GitHubClientInterface],\n};\nexport default githubPlugin;\n"],"mappings":"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","names":[]}